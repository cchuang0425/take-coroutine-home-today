# 今天就能帶回家的 Java Coroutine

## 前言

各位今年聽了 Kotlin 的 coroutine 場次了嗎？Kotlin 語言今年加入了 coroutine 這個另人激賞的機制，我想很多人都想用它來解決開發 Android App 或後端的並行問題。

我是我們團隊的架構設計負責人，曾經也想導入 Kotlin，但與工程師討論過後，仍然維持繼續使用 Java，於是我們得以發現這個 Java 的 coroutine，或說 Fiber 的框架。並且同樣的，與團隊討論過後，採行這個框架來設計我們的產品。

我知道這是一個會影響一個系統很深遠的框架，會改變很多底層機制的使用，也可能會引起額外的問題。所以在前言，我有幾句自己的話要跟各位分享，

(前言內容)

好，我們要進入今天的正題。

## 今天的主講人

我是黃俊鈞，我是今天的主講人，目前任職於資策會，我一向習慣稱自己是程式員。自我介紹很少，因為我希望各位回去時，記得的是今天我們討論的主題，還有最後我放上來的投影片與範例程式的 GitHub。

## 今天的主角

今天的主角是這個框架，Quasar，我們來看看它的官網怎麼介紹它

(Quasar 英文介紹)

讀英文比較慢，我用我的破英文把它翻成了中文

(Quasar 中文介紹)

我們今天會著重在 Quasar 如何使用在 Java 上，與它提供的類似 Go Channel 的機制。希望今天講完之後，各位不只能知道怎麼設定與使用這個框架，也能知道我們在使用當下，是怎麼思考的，在使用過程，是怎樣調校的。

## 今天的脈絡

(今天的脈絡)

我們今天的脈絡，會從我們團隊遇到的問題出發，我知道這與各位實際遇到的問題一定不完全一樣，但是我們把這解法放在某個特定處境中，會讓各位更深刻的理解這個解法與它背後的思考。

提出了問題後，我們會歸納出在這問題中所反映的需求，以及從需求看見解決的機制，接下來我們會看到這機制如何實踐，以及驗證其執行結果。

是的，我們這個場次會看一些程式碼，有些為了寫在投影片上，實際的程式碼會與投影片上的不同，而程式碼在最後一頁投影片中會告訴各位 GitHub 檔案庫的連結。

最後我們會深入討論 Quasar 這個框架的實務使用想法與延伸應用。

## 問題 → 需求

我們通常都是從問題裡產生需求的，不知道各位有沒有遇過這類問題，我們舉個數學計算的例子，來對應到實際工作上更複雜的情況。

(假設我們有個這樣的計算問題)

(費氏數列)

(質數判定)

我們可以看到上述問題寫成程式大概是這樣

(同步執行的程式)

這個問題實際解起來很簡單，當然這是指，我們所有的邏輯都可以放在同一段 block 裡，也可以說是放在同一個 context 裡。我們叫這種執行方式作「同步執行」

(同步執行一)

如果各位有去咖啡店喝手沖咖啡，手沖咖啡大概就是同步執行的一個概念了。當然這裡一定有不喝咖啡的，另一個角度來講，排隊也是同步執行的一種。

(同步執行二)

各位想像一下，一步做完，再下一步，這樣的世界多麼單純美好。

(但好景不常....)

可是這世界並沒有這麼美好，天下之道，合久必分，分久必合。有一天，我們要把裡頭的計算核心分出來成為外部服務

與 Message Queue 介接後，這個程式成了非同步式的執行模式。如果要形容一下非同步是什麼東西，大概像這樣：

(非同步執行)

如果各位有用過電鍋會知道，東西放了之後，就不管它，然後等到它跳起來就好。可是程式怎麼做到這種事呢？

(非同步環境下的同步執行)

如果要把原本的程式轉換成可以執行在非同步的環境下，我們勢必要做一件事，就是等待。我知道時至今日，有許多轉彎的方式可以解決這個問題，但這代價是什麼呢？

我們接下來稍微看一下，若使用完全的非同步方式，我們的程式會變成什麼樣子。

(非同步的 Event Driven)

我就不帶大家看這裡的程式碼，建議各位可以參考範例程式的內容，簡而言之，我會把每一個動作都當作一個 event，並且用 command pattern 進行包裝，因此，首先我們需要使用額外的暫存空間保存 command 的 reference、每個 command 與原始的 n 的對應關係，再者，我們需要在每個 command 裡指定下一步驟是什麼，跑完每個 command 時，需要組合這些經過的對應，而最後跑完時，還有需要一條等待事情完成的 thread。

然而，程式脈絡的大改算是其次，更重要的問題是，

(困難的，不是把它寫出來，而是寫完後要如何維護與擴充！)

當業務邏輯散落在各處時，後續擴充與維護會變得非常複雜。雖然，如果一切重頭來，一開始就知道會有非同步架構的需要的話，我們或許可以使用合適的抽象概念來解決它，例如引入 Akka，但是我相信來到這裡的各位，其實大家可能所處的環境跟我們類似，也就是原本的邏輯是同步式的，或你原本想用的機制就是同步式的。然而碰到了這種非同步的環境，有的人起步還早，可以立馬煞車轉彎，有的人可能希望重複利用過去寫出來的程式，不想做太大的修改，這也是我們今天的主題，希望 Quasar 能幫到有這方面需要的人。

於是在剛剛的問題處境下，我們有了以下需求

(需求)

既然有了需求，我們就能思考解決方法

## 需求 → 機制

(需求 → 機制)

這個問題怎麼解呢? 這就是我們今天要談的主題，Coroutine 與 Continuation

(Coroutine & Continuation)

Coroutine 是什麼呢? 我們從 Wiki 的解釋來看

(Coroutine?)

當然我們一時之間要解讀這段話不太容易，所以我們來看它的中文

(一句一句地說明)

Coroutine 的特別之處，就在於它是一個多進入點的程式區塊，而且不只多進入點，也是個可反覆進入退出的機制。這是怎麼做到的呢？它有個很棒但我實在不知道怎麼翻譯的名詞，叫 Continuation

(Continuation)

Continuation 的解釋頗多，我只有拮取其中一部份，這一部份在說什麼呢

(一句一句地說明)

白話來說，Continuation 是一種可以把程式的控制流轉變成一個可操作的物件或函數的機制，而當捕獲這個控制因子時，程式執行過程的上下文，就是 context，它會被保留下來。這在 Java 裡面有嗎？

(在 Java 有嗎？)

沒錯，當我們拋出一個 checked exception 時，它會中斷執行，但中斷不代表執行的 context 就不見了，它會被保存起來。Java 沒有辦法使用 coroutine 的點就在於，這個中斷時的 context 並不是被某個框架或工具給保留了，而是被 JVM 給拿去管了。於是 Quasar 的作用就在於，它能夠把這個中斷當下的 context 保存在它自己的資料結構裡頭，然後把控制權交給開發者，你就能決定什麼時候要回到這段程式裡繼續執行了。

Coroutine 有什麼優點呢

(優點)

人無千日好，花無百日紅，它也有缺點

(缺點)

當然，使用 JavaAgent 是有前提的，這我們後續會提到，於是我們決定了機制，要來實作了。

## 機制 → 實踐

(機制 → 實踐)

(Quasar 101)

要了解 Quasar，先要明白它裡頭最重要的兩個角色

(Fiber & Channel)

我們借用 Go 的圖，因為在 Quasar 裡頭，Fiber 雖然是個輕量級的 Thread，但要讓它發生 coroutine 的作用，還是得靠 channel 的機制才行。而 Channel 就是在 Fiber 中，或 Fiber 內外，起到資訊傳輸的作用。我們接下來就要來實作今天問題的解決方法

(PrimalityFiber)

首先，我們先設定建構工具，Quasar 對 Gradle 支援較好，所以我們今天先以 Gradle 來說明，Quasar 官網也有 Maven 的設定說明，使用 Maven 的人可以參考 Quasar 的文件。

(Gradle)

在 Gradle 裡頭，我們需要增加一個客製的設定項目，給它一個名字叫 quasar 就好，然後我們除了設定 Quasar 的 dependency 之外，也要設定這個設定項目，指向 quasar 的 jar 檔。這目的是讓我們在 Gradle 裡執行時，可以設定 java agent。如果各位有用 spring boot，也要在 bootRun 這個 task 設定一樣的內容唷

(小眉角)

此外，因為使用 java agent 的關係，我們會額外在部署時使用到 quasar 的 jar 檔，所以我們必須把這個 jar 檔 copy 出來，好方便我們在 IntelliJ 裡或發佈的時候使用

我們再回到 Fiber，來看今天程式裡的 Fiber 怎麼定義與使用

(Fiber)

我們在這裡看到的是，我們不是直接 extend Fiber，就像寫 multi-thread 程式時，不是直接 extend Thread 一樣，而是 implements 一個 callable 或 runnable 的介面，但在 Quasar 裡，這兩個介面名字前面都要加上 Suspendable，表示它們是會拋出中斷例外的

我們像在寫 multi-thread 程式一般定義完了 Fiber 的外框後，接下來就是要來思考，怎麼導入 Channel 來接取從 MQ 回來的值

(與 Channel 共舞)

各位可以看到在這裡，有一個 receiveFromeChannel 的 method 包裝著 service 的呼叫，看到這名字就知道，可能是 service 會回傳一個 channel，就像這樣

(謎底之一)

接回了 Channel 之後，我們在 Fiber 裡把 channel 的值接出來，像這樣

(謎底之二)

這裡會這樣寫，是不合格的，首先，Channel 像 IO Stream 一樣，都有 AutoClosable 的實作，所以可以用 try 的語法來包裝，其次，其實我們只是為了呼應前面說到非同步環境下的同步程式，所以用這種寫法，其實你自己在寫時，這樣會更好

(這樣會更好)

最後是最關鍵的地方，有寫過 JMS 程式的會知道，我們需要有一個 consumer 來監聽 message queue 回來的訊息，收回訊息後，我們就把它轉成物件，並且回傳給這個訊息對應的 channel

(謎底之三)

在此，各位會看到我們有一個 try-cache block 用來捕捉兩個 exception，一個是寫 multi-thread 常見的 interrupted exception，另一個不叫 exception，叫做 suspend execution，這就是剛才我們說到的，透過 try-cache 把程式中斷的機制，但在此我們設定了 try-cache，就必須在 method 上註記說這個 method 會 suspend，所以要有個 Suspendable 的 annotation。到此，大家已經知道整個概念是如何實作的了，我們來執行看看結果如何

## 實踐 → 驗證

(實踐 → 驗證)

## 深入探討 － Quasar

(深入探討 － Quasar)

解決了基本的問題後，我們要來深入地發掘這個框架的特性

首先，有的人可能會問，Java Agent 是什麼?

(JavaAgent?)

簡而言之，就是即便 Java 是編譯型的語言，但卻能在執行時期改變程式的狀態，或監控程式的狀態。那有的人可能在 Quasar 的網站上會看到另一個機制，叫 AOT

(Why not AOT?)

我們直接來試試看剛剛的程式

從我們修改的 gradle 設定，各位可以看到我們執行時已經不用 java agent 了，這跟之前說的差別在哪呢?

(差別在哪裡呢？)

我們團隊後來，就建議使用 AOT 為優先，因為需要 suspend 的大多是自己開發的，再者，Quasar 包出來的 JAR 在某些情況下，做為 Java Agent 使用會出錯，用 AOT 反而沒這問題

那我想大多數人會用在 web 上，有給 web 用的嗎?

(如何使用在 WAR in Tomcat 的環境呢？)

Comsat 是 Quasar 的整合套件，讓你可以把 Quasar 整合到不同的環境裡，但它更新時間只到 2016 年，這也是我剛才說的缺點項目之一

(既然是 Continuation，可以使用 Generator 嗎?)

可能也有的人，使用過別的語言的 Coroutine，有用過的一定知道在其他語言裡，Coroutine 除了拿來處理 concurrency 的問題之外，另一個作用就是當 generator

我們看另一段範例程式

(既然是 Coroutine，可以像 Python/Lua 那樣 yield 嗎？)

我在使用 Thread 時，覺得最難控制的，就是 Thread 的 yield，因為 Thread 的 yield 只是讓 thread pool 知道它現在可以讓出一下控制權，但無法真的暫停這個 thread，那麼 Quasar 有類似 Python 或 Lua 的 yield 機制，可以把 Fiber 整個停掉嗎? 當然有

不只可以 yield，還提供了進階開發者使用的 park 跟 unpark，詳細部份可以參考 Quasar 的 Java doc

最後我們來說說其他使用 Quasar 時要注意的事情

(其它注意事項)

在使用 Quasar 時，有一些提供 production time 使用的設定，可以讓你的 Fiber 執行的比較順暢

(其他設定)

講完了這個 3rd party 的 coroutine，我們心裡是否有疑問，難道 Java 真的沒有嗎? 嗯，的確有，但還在研議中

(What's Next?)

還有些時間，我補充一下，除了使用 Coroutine 之外，對應那個問題是否還有其他解法呢

(除了 Coroutine，有其他解法嗎？)

(其他解法之一：Producer Consumer Pattern)

Producer Consumer Pattern 相信是大多數人在進入並行開發時的基本功，使用 Thread 也有其優點，如同 Quasar 官方文件說的，如果你的工作是以計算為主，建議你使用 Thread

(優點)

而 Producer Consumer Pattern 在使用時，中間通訊的 Queue 的確很像 Channel 的使用，可是請記得，這個時候，就是 Thread 在等待 Blocking Queue 回傳值的時候，Thread 是活著的，不是被暫時停住的

(缺點)

當然還有一個解法，就是整個拆成非同步式的寫法

(Asynchronous)

它的優點是

(優點)

當然，難免的我們要談談它的缺點

(缺點)

講完了這些解決方案，希望能夠減少各位嘗試導入時的碰壁過程，但並行開發或甚至平行開發，並不是有了 coroutine 就可以解決更本質性的問題，但希望藉著研究這些機制，研究進階的平行與並行開發概念，我們可以寫出更快、更優雅、更有效率的程式

(最後，希望各位不吝指教)

感謝各位今天的參與，如果有對於今天內容的想法與 feedback，可以發在投影片的 issue 裡頭，

(本場次原始碼)

今天原始碼在此，希望對各位有所幫助，謝謝各位