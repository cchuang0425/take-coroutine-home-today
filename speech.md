# 今天就能帶回家的 Java Coroutine

## 關於我

我一向習慣自我介紹自己是一個程式員，現在任職於資策會。

## 前言

我的工作，有很大的一部份是在做架構設計的事，並且設計完後，把這架構由 0 到 1 實作出來後，就要交給開發團隊去實作其他各種功能。因此，在進入今天的議題之前，我要先跟大家說一點我個人的信念。

架構設計有賺有賠，導入前請詳閱公開說明文件。所有的設計都是 trade off，沒有最好或萬用的解法，在這點，我甚至覺得，人家可能說只有最適合，這點在我看來，其實也不成立。為什麼呢？可能某個解決方法，在現在時空背景下看起來適用，可是當我們對問題領域的了解越來越深，當初看到的問題越來越不是問題，解決方案所帶來的問題越來越大時，就會發現當初選擇的架構解法不一定真的那麼適合。

所以，架構設計沒有最好或萬用的解法，只有考慮清楚、討論充足後，整個團隊上上下下願意一同承擔風險的解法。

## 大綱

我們今天的主角是 Quasar，這個字中文翻譯是星雲，就是宇宙、銀河裡的那個星雲。它的開發廠商叫 Parallel Universe，就是平行宇宙的意思。這是不是聽起來很有科幻感呢？

我會從我們遇到的問題切入，然後先跟各位說明 Quasar 怎樣導入，以及怎樣設定。接下來會跟各位解釋一下 Quasar 的 Fiber 與 Coroutine 這兩個概念的意涵。

但重點會放在 Quasar 使用到的一個很特殊的機制，叫做 Continuation，這沒有合適的中文翻譯，姑且叫它延續性好了。

最後我會說明我們實際在專案上使用 Quasar 之後，所看到的問題，這就是我在前言所說的。還有時間的話，我希望可以做個結論。

## 處境

所有的架構設計，都是從實際問題與解決的抽象模型而來。而我們碰到的問題，其實我相信各位在開發現場一定也遇到過。

那就是當我們要將原本是同步式的執行流程改成非同步式的機制去實作時，就是豬羊變色的時候了。

原本一切單純美好，這步做完做下一步，大家條件滿足時，開開心心地結束。可是，後來我們把其中一些步驟切割出去成為另一個服務。

在這過程裡，我們考慮過兩種選項，第一種，是切割成 Web Service，如果我們選擇了這種，那一切依然單純美好，只是稍有些變化而已。

然而，我們原本的產品是右邊那塊，幾經思考後，考量安全、可擴充性、產品定位等議題之後，決定選擇另一種解法，就是第二個解決方案。

透過 middleware，就是中間的 message queue，進行資料的交換，右邊的這個系統自己不開 port，而是作為一個 smart agent 的角色，實作一個大型的、command pattern 為基礎的這樣的系統。

那也幾年過去相安無事，右邊這系統我用 Java 的傳統 thread 就做完了。但各位，事情沒那麼簡單的地方就在於，原本左邊那塊是讓外部廠商自己傷腦筋的部份。最後我們自己也得做一套這樣的系統。

換句話說，我們也遇上了原本同步式的執行流程，現在要轉成非同步的了。

這是指，若按照傳統的寫法，當訊息出去到 MQ 後，程式必須停在那裡，直等到回傳值進來後，才能繼續做事。

這點意味著，我必須用 Blocking 的機制，把一堆 thread block 在 thread pool 裡頭，各位如果有寫 thread 的經驗會知道，producer consumer pattern 的機制，是沒有 sleep 的機會的，consumer 拿不到時，就是 blocking，沒有辦法 sleep。而如果硬要 sleep，就不能使用 wait 的方式來呼叫。也不能叫做 producer consumer pattern 了，更不能用 BlockingLinkedQueue 這個 data structure 來做。

